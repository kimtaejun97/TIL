# 💻 운영체제
****
> 시스템의 자원과 동작을 관리하는 시스템 소프트웨어.


# 📌 프로세스
***
- 프로세스는 최소 1개 이상의 쓰레드를 가진다.
- 프로세스는 Code, Data, Heap, Stack 영역을 가지며, Stack 영역은 쓰레드마다 생성되고, 나머지는 공유된다.
> - Code : 코드를 구성하는 메모리 영역, 프로그램 명령 등.
> - Data : static 변수, 전역변수, 배열 등 초기화된 데이터가 저장된다.
> - Heap : 동적 할당시 저장되는 장소, new Operation 등.
> - Stack : 지역변수, 매개변수, 반환 값을 저장. 임시 메모리 영역

### ☝️ 멀티 프로세스
- 여러개의 프로세스를 병렬적으로 처리한다. 
- Context Switching 이 발생하기 때문에 오버헤드가 있다.
    - 동작중인 프로세스의 상태를 저장하고, 이전에 보관한 프로세스의 상태를 복원하는 과정.
    - 인터럽트의 발생, CPU 사용시간 소모, 입출력 대기 등.
    - 즉, 프로세스의 상태 변경시 발생
    
### ☝️ 멀티 쓰레드
- 한 프로세스에서 다수의 작업을 동시에 처리.
- 공유 자원을 사용하기 때문에 동기화 처리 등 발생할 수 있는 문제를 고려해야 한다.

## 🧐 PCB(Process Control Block)
- 프로세스 메타데이터를 저장하는 곳
    - Id
    - 상태
    - 우선순위
    - CPU Registers
    - 메모리, CPU 사용량 등.

- Context Switch 가 발생할 때 다시 수행할 대기 프로세스에 관한 값들을 저장하기 위해 사용한다.
- Linked List 방식으로, 프로세스가 생성되면 추가되고, 완료되면 삭제된다.

# 📌 프로세스간 통신 IPC(Inter-Process Communication)
****
- 프로세스는 독립적으로 실행되어 서로에게 영향을 받지 안흔다.
- 프로세스는 커널이 제공하는 IPC 설비를 이용하여 서로 통신한다.

### 1. 익명 PIPE
- 통신할 프로세스를 명확하게 알 때 사용.(부모-자식)
- 단방향 통신(한쪽은 읽기, 한쪽은 쓰기.)
- 양방향으로 통신하고 싶다면 2개의 파이프가 필요하다.
- 구현이 간단하지만 양방향 통신을 하기 위해서는 구현이 복잡해진다.

### 2. Named PIPE
- 통신할 프로세스를 알지 못할 때 사용.
- 익명 파이프의 확장, 무관한 프로세스와도 통신이 가능

### 3. Message Queue
- 입출력 방식은 파이프와 동일
- 파이프와 달리 데이터의 흐름이 아닌 메모리 공간.
- 데이터에 번호를 붙이고 여러 프로세스에서 데이터를 다룰 수 있다.

### 4. 공유 메모리
- 통신을 이용한 설비가 아닌 말 그대로 자원의 공유.
- 프로세스간 메모리 영역을 공유하여 사용할 수 있도록 한다. 곧바로 접근이 가능하기 때문에 가장 빠름.
> - 프로세스가 공유 메모리 할당을 커널에 요청
> - 커널은 메모리 공간을 할당. 모든 프로세스는 해당 메모리 영역에 접근 가능.

### 5. 메모리 맵
- 공유 메모리와 같이 메모리를 공유.
- 열린 파일을 메모리에 맵핑 시켜 공유, 대용량 데이터를 공유할 때 사용.

### 6. Socket
- 네트워크 소켓 통신을 이용한 데이터 공유
- 클라이언트-서버 통신 구조.

#### 🖍 IPC 통신에서 동기화, 각종 문제 발생을 해결하기 위해 세막포, 뮤텍스 등의 방법을 사용.


# 📌 인터럽트
***
> 더 중요한 일 발생으로 실행중인 작업을 즉시 중단하고, 발생된 상황의 처리를 우선으로 할 것을 CPU에게 알리는 것.
> - 발생시기를 예측하기 힘든 경우에 빠르게 대응할 수 있게 해준다.
> 
- 폴링 방식 : 사용자 명령어를 사용해 값을 계속 읽어 변화를 감지.
- 인터럽트 : MCU 자체가 하드웨어적으로 변화를 체크, 변화가 있을 경우에만 동작.


### 🧐 외부 인터럽트
- 입출력, 타이밍 장치, 전원 등의 외부적인 요인

### 🧐 내부 인터럽트
- Trap
- 잘못된 명령이나 데이터로 인해 발생하는 인터럽트.
  - (overflow, zero division, Exception 등)
    
### 🧐 소프트웨어 인터럽트
- 명령의 요청에 의해 발생.
- 사용자가 다른 프로세스를 실행 등.

```
- 인터럽트 발생
- 복귀주소 저장(PC, 레지스트 등 스택에 저장.).
- 인터럽트 백터로 점프.
- 인터럽트 처리.
- 복귀 주소 로드.
- 복귀 주소로 점프.
- 이전에 실행하던 프로세스 실행.
```

# 📌 CPU 스케줄링
***
- 가능한 많은 일을 수행.
- 빠른 응답 시간, 적은 대기 시간.
- deadline 내에 수행.

- Response Time : 작업이 처음 실행되기 까지 걸린 시간
- Turn Around Time : 실행시간 + 대기 시간.

### ☝️ 프로세스 상태
![img_1.png](img_1.png)
> - new : 프로세스 생성
> - Admitted : 프로세스 생성이 가능하여 승인.
> - Ready : 프로세스 실행이 가능해져 차례를 기다림.
> - Scheduler Dispatch : Ready에 있는 프로세스 중 하나를 실행.
> - Running : 현재 실행중인 프로세스
> - Interrupt : 예외, 입출력 등이 발생하여 다른 작업을 먼저 처리.
> - IO | Event Wait : 실행중인 프로세스가 입출력이나 이벤트를 대기.
> - Waiting : 발생한 입출력이나 이벤트가 모두 끝날때까지 대기하는 상태.
> - IO | Event Completion : 입출력이나 이벤트가 끝나 다시 Ready 상태로 전환.


## 🧐 CPU 스케줄링의 종류

### ☝️ 비선점(onpreemptive) 스케줄링
> 프로세스 종료 또는 IO 등의 이벤트가 있을때 까지 실행을 보장.
- #### ✏️ FCFS(First come First Served)
  - 말 그대로 큐에 도착한 순서대로 할당.
  - 실행시간이 긴 프로세스가 앞에 오면 평균 대기시간이 길어진다.
    
- #### ✏️ SJF(Shortest Job First)
  - 실행시간이 짧은 프로세스 부터 수행.
  - FCFS 보다️ 평균 대기시간이 감소
  
- #### ✏️ HRN(Highest Response-ratio Next)
  - 우선순위를 계산하여 점유 불평등을 해결(SJF 보완)
  - 우선순위 = (대기시간 + 실행시간) / 실행시간
  - 대기시간이 길어지면 우선순위가 높아짐.


### ☝️ 선점(Preemptive) 스케줄링
> OS가 CPU 사용권을 강제 회수. 종료까지 실행을 보장하지 않는다.
- #### ✏️ Priority Scheduling
  - 우선 순위를 부여하여 우선순위가 높은 순서대로 처리
  - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation이 발생할 수 있다.
  - Aging을 적용하여 해결 가능.(들어온 시간이 지날수록 우선순위가 높아짐.)

- #### ✏️ Round Robin
  - FCFS에 더에 각 프로세스는 동일한 TimeQuantum을 할당 받으며, 해당 시간만큼 수행한 후 다른 프로세스에게 CPU 점유를 넘긴다.
  - Time Quantum 을 너무 크게 주면 FCFS가 되고, 너무 적게 주면 Context Switching 이 자주 발생하므로 오버헤드 증가.
  
- #### ✏️ MultiLevel Queue(다단계 큐)
  - 여러 개의 큐에 서로 다른 스케줄링 기법을 적용.
  - 우선순위가 높은 작업(빠른 반응 속도를 요구하는 작업)에는 TimeQuantum을 작게.
  - 우선순위가 낮은 작업에는 TimeQuantum을 크게 할당.
  
- #### ✏️ MultiLevel Feedback Queue
  - 다단계 큐와 유사하지만 Time Quantum을 모두 소모한 프로세스가 밑의 큐로 이동한다.(즉, 우선순위가 한단계 낮아짐.)
  - 짧은 작업 처리에 유리, Turn around Time 을 줄여줌.(대기 + 실행시간)
  
  
# 📌 DeadLock : 교착상태
> 프로세스가 자우너을 얻지 못해서 다음 처리를 하지 못하는 상태.
> 한정적인 자원을 공유하기 때문에 발생한다.

## 🧐 교착상 발생 조건
> 상호 배제, 점유 대기, 비선좀, 순환 대기 4가지가 모두 성립될 때 교착 상태가 발생한다.

### ☝️ 상호 배제(Mutual exclusion)
- 자원은 한 프로세스에서만 접근할 수 있다.(한번에 여러 프로세스에서 한 자원을 사용할 수 없다.)

### ☝️ 점유 대기 (Hold and Wait)
- 최소 하나의 자원을 점유하고, 다른 프로세스에 할당된 자원을 기다리는 프로세스가 존재.

### ☝️ 비선점(non-preemption)
- 다른 프로세스에 할당된 자원은 강제로 빼앗을 수 없다.

### ☝️ 순환 대기(Circular Wait)
- 프로세스의 집합에서 순환 형태로 자원을 대기.
- 1번 프로세스가 자원 A를 가지고 자원 B를 요청, 2번 프로세스가 자원 B를 가지고 자원 A를 요청.

## 🧐 교착상태 해결

### ☝️ 예방(prevention)
- 교착상태 발생 조건중 하나를 제거.(자원 낭비가 있음)

  - 상호 배제 부정 : 여러 프로세스가 공유자원을 사용.
  - 점유 대기 부정 : 
    - 미리 점유하지 않고 프로세스 실행전 모든 자원을 한번에 할당.(자원 낭비)
    - 자원을 점유하지 않고 있을 때에만 다른 자원 요청 가능(기아 상태 발생 가능)
  - 비선점 부정 : 다른 프로세스에서 자원을 요구할 때 가진 자원을 반납.(이미 실행중이 었기 때문에 자원이 낭비됨.)
  - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구.
  
### ☝️ 회피(Avoidance)
- 교착 상태 발생을 피한다.
- 은행원 알고리즘.
  - 가정
    - 프로세스 수가 고정
    - 자원의 종류와 수가 고정
    - 프로세스가 요구하는 자원, 최대 자원의 수를 알아야한다.
    - 프로세스는 반드시 자원을 반납.

  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당 한 후에도 안정 상태인지(모든 프로세스가 정상적으로 종료가능한 상태) 검사 후 할당.
  - 자원을 할당했을 때 안정상태가 아니라면 다른 프로세스의 자원이 해지될때까지 대기한다.
  - 안정 상태 : 남은 여유 자원으로 종료할 수 있는 프로세스 탐색 -> 해당 프로세스를 종료시키고 반환된 자원으로 다시 탐색.. 의 반복을 통해 모든 프로세스를 종료할 수 있는지.
  
- 자원 할당 그래프 알고리즘
  - 그래프를 그리고 향후 요청할 수 있는 자원을 점선을 예약 간선으로 표시.
  - 사이클이 발생한다면 자원 요청을 승인하지 않는다.

### ☝️ 교착상태의 탐지와 회복

#### ✏️ 탐지(Detection)
> 교착 상태가 발생했는지 탐지.
- 대기 그래프
  - 자원 할당 그래프에서 자원을 제거, 간선을 결합.
  - 다른 프로세스의 자원을 기다리는 것을 화살표로 표시.
  - 사이클이 생긴다면 교착상태를 의미.
- 은행원 알고리즘 : 불안정 상태라면 교착상태라고 판단.

#### ✏️ 회복(Recovery)
> 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제.

1. 프로세스 종료 방법
    1. 교착 상태의 프로세스를 모두 중지하는 방법.
    2. 교착 상태가 제거될 때 까지 하나씩 프로세스를 중지시켜 나감.

2. 자원 선점
    - 희생자 선택 : 최소의 피해를 가져오는 프로세스 선택후 자원을 해제, 다른 프로세스에게 할당.
      - 우선순위가 낮은 프로세스, 실행 빈도가 낮은 프로세스를 주로 선택한다.
      - 기아 상태가 발생할 수 있으므로 이를 해결하는 방법이 필요.(자원을 선점 당할때 마다 우선순위 증가 등.)
    - 롤백 : 선점된 프로세스를 이전 상태로 롤백(중단 후 재시작)


# 📌 경쟁 상태(Race Condition)
***
> 동시 접근으로 원하는 결과가 발생하지 못한다.
## 🧐 발생
### ☝️ 커널 작업을 수행하는 중에 인터럽트 발생
- 커널모드에서 작업을 수행하다가 인터럽트가 발생, 같은 데이터를 조작하는 경우.
- 커널 모드에서 작업을 수행하는 동안 인터럽트를 Disable 시켜 발생을 막는다.

### ☝️ System Call
- 프로세스 1에서 데이터를 조작하는 도중 시간을 모두 소모하여 CPU 제어권이 프로세스 2로 넘어가게 되고, 같은 데이터를 조작
- 시간을 모두 소모하여도 CPU 제어권을 넘기지 않도록 한다.

### ☝️ 멀티 환경에서 공유 메모리의 접근
- 2개의 프로세스 또는 스레드가 공유 데이터에 접근하여 데이터를 조작.
- 데이터를 사용할 때 lock을 걸어둔다.

## 🧐 해결

### ☝️ 세마포어(Semaphore)
> 멀티 환경에서 공유자원에 대한 접근 제한.
#### 🖍 임계 구역(Critical Section) : 공유 데이터에 접근하는 부분.


- 플래그를 두고 데이터에 접근할때 접근함을 표시.
- 사용하고 나온 뒤에는 다시 플래그를 변경해두면 다른 프로세스가 이를 확인하고 접근.
- while 문을 사용하여 flag를 확인한다.
- Wait, Signal

### 뮤텍스 알고리즘
- flag와 turn을 이용하여 임계 구역에 들어갈 프로세스를 결정.
- flag : 누가 임계 구역에 진입 할 것인지.
- turn : 누가 임계 구역에 진입할 차례인지.

#### - 데커(Dekker) 알고리즘
```java
flag[i] = true; 
while(flag[j]) { 
    if(turn == j) { 
        flag[i] = false; 
        while(turn == j); 
        flag[i] = true; 
    }
}
//{Critical Section}
turn = j; 
flag[i] = false; 
```
- j의 turn 이라면 기다리다가 j가 끝나고 turn을 i로 설정하면 진입.
- 사용하고 나면 자신의 플래그를 false로 하고, turn 을 넘겨준다.

#### - 피터슨(Peterson) 알고리즘
- 다른 프로세스에게 진입 기회를 먼저 양보.
- 다른 프로세스가 진입 시도중이라면 기다림.

```java
flag[i] = true;
turn = j;
while(flag[j] && turn == j){}
// { Critical Section}
flag[i] = false;
```

### Bakery 알고리즘
- 번호표를 발급받고 가장 적은 수의 번호표를 가진 프로세스가 먼저 접근.


# 📌 메모리
***

- 메인 메모리는 CPU가 직접 접근할 수 있는 기억 장치
- 주소가 할당된 일련의 바이트
- 명령어, 명령어 수행시 메모리에 필요한 데이터를 가져옴.

### ☝️ 메모리 관리장치 MMU(Memory Management Unit)
- 메모리 보호, 캐시 관리 등 CPU가 메모리에 접근 하는것을 관리.
- 논리 주소를 물리주소로 변환.

- 프로세스에게 합법적인 주소 영역을 설정, 잘못된 접근에대해 Trap을 발생시켜 보호.
  - base : 메모리상의 프로세스 시작 주소.
  - limit : 프로세스의 사이즈
  - 즉 접근 범위는 base 이상 base + limit 미만.
  

## 🧐 페이지 교체
- 가상 메모리를 이용하여 메모리를 할당 했을 때 과할당이 발생할 수 있다.
- 이를 해결하기 위해 프로세스를 Swap out하고, 이 공간을 빈 프레임으로 활용하여 해당 빈 프레임에 페이지를 올린다.

1. 페이지 폴트 발생
2. 페이지 폴트가 발생한 페이지를 디스크에서 탐색.
3 .메모리에 빈 프레임 탐색.
  - 있으면 빈 프레임 사용, 없다면 희생 프레임을 선정해 디스크에 기록하고, 페이지 테이블을 업데이트
4. 빈 프레임에 포릍가 발생한 페이지를 올리고 페이지 테이블 업데이트.

#### 🖍 오버헤드 발생
  - 희생 프레임을 비울 때, 원하는 페이지를 프레임에 올릴 때, 두번의 디스크 접근이 이루어진다.
  - 적절한 교체로 오버헤드를 줄여야 함.

### 🔑 페이지 교체 알고리즘
> 안쓰는 페이지를 내리고, 현재 필요한 페이지를 추가, 이때 어떤 페이지를 내려야할지 결정하는 알고리즘.

#### ✏️ FIFO
- 가장 먼저 올라온(올라온지 오래된) 페이지를 out 시킨다.
- 초기화 코드를 out 시킬때 적절.

#### ✏️ Optimal 알고리즘
- 앞으로 가장 사용하지 않을 페이지를 우선적으로 내보낸다.
  - 하지만 실질적으로 사용하지 않음을 보장할 수 없기 때문에 수행하기 어려움.
- FIFO에  비해 페이지 결함의 횟수가 많이 감소된다. 

#### ✏️ LRU(Least-Recently-Used)
- 최근에 사용하지 않았다면 다시 사용될 확률이 낮다는 아이디어.
- 과거를 보기 때문에 실제로 사용할 수 있다.
- 사용한지 가장 오래된 페이지를 교체.







## 캐시
- 재접근 할때 메모리의 참조 비용을 줄이기 위해 사용
- CPU에서 주소를 전달 -> 캐시에서 먼저 확인 -> Hit이면 명령어를 가져옴, Miss면 주기억 장치에 접근.
- 캐싱 라인 : 캐시 데이터를 저장할 때 자료구조를 활용(map,set 등)

### ☝️ 지역성
  - 시간 지역성 : 최근에 참조된 주소가 곧 다시 참조될 것이다.
  - 공간 지역성 : 프로그램이 참조된 주소와 인접 주소의 내용이 다시 참조될 것이다.


  

