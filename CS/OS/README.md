# 💻 운영체제
****
> 시스템의 자원과 동작을 관리하는 시스템 소프트웨어.


# 📌 프로세스
***
- 프로세스는 최소 1개 이상의 쓰레드를 가진다.
- 프로세스는 Code, Data, Heap, Stack 영역을 가지며, Stack 영역은 쓰레드마다 생성되고, 나머지는 공유된다.
> - Code : 코드를 구성하는 메모리 영역, 프로그램 명령 등.
> - Data : static 변수, 전역변수, 배열 등 초기화된 데이터가 저장된다.
> - Heap : 동적 할당시 저장되는 장소, new Operation 등.
> - Stack : 지역변수, 매개변수, 반환 값을 저장. 임시 메모리 영역

### ☝️ 멀티 프로세스
- 여러개의 프로세스를 병렬적으로 처리한다. 
- Context Switching 이 발생하기 때문에 오버헤드가 있다.
    - 동작중인 프로세스의 상태를 저장하고, 이전에 보관한 프로세스의 상태를 복원하는 과정.
    - 인터럽트의 발생, CPU 사용시간 소모, 입출력 대기 등.
    - 즉, 프로세스의 상태 변경시 발생
    
### ☝️ 멀티 쓰레드
- 한 프로세스에서 다수의 작업을 동시에 처리.
- 공유 자원을 사용하기 때문에 동기화 처리 등 발생할 수 있는 문제를 고려해야 한다.

## 🧐 PCB(Process Control Block)
- 프로세스 메타데이터를 저장하는 곳
    - Id
    - 상태
    - 우선순위
    - CPU Registers
    - 메모리, CPU 사용량 등.

- Context Switch 가 발생할 때 다시 수행할 대기 프로세스에 관한 값들을 저장하기 위해 사용한다.
- Linked List 방식으로, 프로세스가 생성되면 추가되고, 완료되면 삭제된다.

# 📌 프로세스간 통신 IPC(Inter-Process Communication)
****
- 프로세스는 독립적으로 실행되어 서로에게 영향을 받지 안흔다.
- 프로세스는 커널이 제공하는 IPC 설비를 이용하여 서로 통신한다.

### 1. 익명 PIPE
- 통신할 프로세스를 명확하게 알 때 사용.(부모-자식)
- 단방향 통신(한쪽은 읽기, 한쪽은 쓰기.)
- 양방향으로 통신하고 싶다면 2개의 파이프가 필요하다.
- 구현이 간단하지만 양방향 통신을 하기 위해서는 구현이 복잡해진다.

### 2. Named PIPE
- 통신할 프로세스를 알지 못할 때 사용.
- 익명 파이프의 확장, 무관한 프로세스와도 통신이 가능

### 3. Message Queue
- 입출력 방식은 파이프와 동일
- 파이프와 달리 데이터의 흐름이 아닌 메모리 공간.
- 데이터에 번호를 붙이고 여러 프로세스에서 데이터를 다룰 수 있다.

### 4. 공유 메모리
- 통신을 이용한 설비가 아닌 말 그대로 자원의 공유.
- 프로세스간 메모리 영역을 공유하여 사용할 수 있도록 한다. 곧바로 접근이 가능하기 때문에 가장 빠름.
> - 프로세스가 공유 메모리 할당을 커널에 요청
> - 커널은 메모리 공간을 할당. 모든 프로세스는 해당 메모리 영역에 접근 가능.

### 5. 메모리 맵
- 공유 메모리와 같이 메모리를 공유.
- 열린 파일을 메모리에 맵핑 시켜 공유, 대용량 데이터를 공유할 때 사용.

### 6. Socket
- 네트워크 소켓 통신을 이용한 데이터 공유
- 클라이언트-서버 통신 구조.

#### 🖍 IPC 통신에서 동기화, 각종 문제 발생을 해결하기 위해 세막포, 뮤텍스 등의 방법을 사용.


# 📌 인터럽트
***
> 더 중요한 일 발생으로 실행중인 작업을 즉시 중단하고, 발생된 상황의 처리를 우선으로 할 것을 CPU에게 알리는 것.
> - 발생시기를 예측하기 힘든 경우에 빠르게 대응할 수 있게 해준다.
> 
- 폴링 방식 : 사용자 명령어를 사용해 값을 계속 읽어 변화를 감지.
- 인터럽트 : MCU 자체가 하드웨어적으로 변화를 체크, 변화가 있을 경우에만 동작.


### 🧐 외부 인터럽트
- 입출력, 타이밍 장치, 전원 등의 외부적인 요인

### 🧐 내부 인터럽트
- Trap
- 잘못된 명령이나 데이터로 인해 발생하는 인터럽트.
  - (overflow, zero division, Exception 등)
    
### 🧐 소프트웨어 인터럽트
- 명령의 요청에 의해 발생.
- 사용자가 다른 프로세스를 실행 등.

```
- 인터럽트 발생
- 복귀주소 저장(PC, 레지스트 등 스택에 저장.).
- 인터럽트 백터로 점프.
- 인터럽트 처리.
- 복귀 주소 로드.
- 복귀 주소로 점프.
- 이전에 실행하던 프로세스 실행.
```

# 📌 CPU 스케줄링
***
- 가능한 많은 일을 수행.
- 빠른 응답 시간, 적은 대기 시간.
- deadline 내에 수행.

- Response Time : 작업이 처음 실행되기 까지 걸린 시간
- Turn Around Time : 실행시간 + 대기 시간.

### ☝️ 프로세스 상태
![img_1.png](img_1.png)
> - new : 프로세스 생성
> - Admitted : 프로세스 생성이 가능하여 승인.
> - Ready : 프로세스 실행이 가능해져 차례를 기다림.
> - Scheduler Dispatch : Ready에 있는 프로세스 중 하나를 실행.
> - Running : 현재 실행중인 프로세스
> - Interrupt : 예외, 입출력 등이 발생하여 다른 작업을 먼저 처리.
> - IO | Event Wait : 실행중인 프로세스가 입출력이나 이벤트를 대기.
> - Waiting : 발생한 입출력이나 이벤트가 모두 끝날때까지 대기하는 상태.
> - IO | Event Completion : 입출력이나 이벤트가 끝나 다시 Ready 상태로 전환.


## 🧐 CPU 스케줄링의 종류

### ☝️ 비선점(onpreemptive) 스케줄링
> 프로세스 종료 또는 IO 등의 이벤트가 있을때 까지 실행을 보장.
- #### ✏️ FCFS(First come First Served)
  - 말 그대로 큐에 도착한 순서대로 할당.
  - 실행시간이 긴 프로세스가 앞에 오면 평균 대기시간이 길어진다.
    
- #### ✏️ SJF(Shortest Job First)
  - 실행시간이 짧은 프로세스 부터 수행.
  - FCFS 보다️ 평균 대기시간이 감소
  
- #### ✏️ HRN(Highest Response-ratio Next)
  - 우선순위를 계산하여 점유 불평등을 해결(SJF 보완)
  - 우선순위 = (대기시간 + 실행시간) / 실행시간
  - 대기시간이 길어지면 우선순위가 높아짐.


### ☝️ 선점(Preemptive) 스케줄링
> OS가 CPU 사용권을 강제 회수. 종료까지 실행을 보장하지 않는다.
- #### ✏️ Priority Scheduling
  - 우선 순위를 부여하여 우선순위가 높은 순서대로 처리
  - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation이 발생할 수 있다.
  - Aging을 적용하여 해결 가능.(들어온 시간이 지날수록 우선순위가 높아짐.)

- #### ✏️ Round Robin
  - FCFS에 더에 각 프로세스는 동일한 TimeQuantum을 할당 받으며, 해당 시간만큼 수행한 후 다른 프로세스에게 CPU 점유를 넘긴다.
  - Time Quantum 을 너무 크게 주면 FCFS가 되고, 너무 적게 주면 Context Switching 이 자주 발생하므로 오버헤드 증가.
  
- #### ✏️ MultiLevel Queue(다단계 큐)
  - 여러 개의 큐에 서로 다른 스케줄링 기법을 적용.
  - 우선순위가 높은 작업(빠른 반응 속도를 요구하는 작업)에는 TimeQuantum을 작게.
  - 우선순위가 낮은 작업에는 TimeQuantum을 크게 할당.
  
- #### ✏️ MultiLevel Feedback Queue
  - 다단계 큐와 유사하지만 Time Quantum을 모두 소모한 프로세스가 밑의 큐로 이동한다.(즉, 우선순위가 한단계 낮아짐.)
  - 짧은 작업 처리에 유리, Turn around Time 을 줄여줌.(대기 + 실행시간)
  
  
# 📌 DeadLock : 교착상태
> 프로세스가 자우너을 얻지 못해서 다음 처리를 하지 못하는 상태.
> 한정적인 자원을 공유하기 때문에 발생한다.

## 🧐 교착상 발생 조건
> 상호 배제, 점유 대기, 비선좀, 순환 대기 4가지가 모두 성립될 때 교착 상태가 발생한다.

### ☝️ 상호 배제(Mutual exclusion)
- 자원은 한 프로세스에서만 접근할 수 있다.(한번에 여러 프로세스에서 한 자원을 사용할 수 없다.)

### ☝️ 점유 대기 (Hold and Wait)
- 최소 하나의 자원을 점유하고, 다른 프로세스에 할당된 자원을 기다리는 프로세스가 존재.

### ☝️ 비선점(non-preemption)
- 다른 프로세스에 할당된 자원은 강제로 빼앗을 수 없다.

### ☝️ 순환 대기(Circular Wait)
- 프로세스의 집합에서 순환 형태로 자원을 대기.
- 1번 프로세스가 자원 A를 가지고 자원 B를 요청, 2번 프로세스가 자원 B를 가지고 자원 A를 요청.

## 🧐 교착상태 해결

### ☝️ 예방(prevention)
- 교착상태 발생 조건중 하나를 제거.(자원 낭비가 있음)

  - 상호 배제 부정 : 여러 프로세스가 공유자원을 사용.
  - 점유 대기 부정 : 
    - 미리 점유하지 않고 프로세스 실행전 모든 자원을 한번에 할당.(자원 낭비)
    - 자원을 점유하지 않고 있을 때에만 다른 자원 요청 가능(기아 상태 발생 가능)
  - 비선점 부정 : 다른 프로세스에서 자원을 요구할 때 가진 자원을 반납.(이미 실행중이 었기 때문에 자원이 낭비됨.)
  - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구.
  
### ☝️ 회피(Avoidance)
- 교착 상태 발생을 피한다.
- 은행원 알고리즘.
  - 가정
    - 프로세스 수가 고정
    - 자원의 종류와 수가 고정
    - 프로세스가 요구하는 자원, 최대 자원의 수를 알아야한다.
    - 프로세스는 반드시 자원을 반납.

  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당 한 후에도 안정 상태인지(모든 프로세스가 정상적으로 종료가능한 상태) 검사 후 할당.
  - 자원을 할당했을 때 안정상태가 아니라면 다른 프로세스의 자원이 해지될때까지 대기한다.
  - 안정 상태 : 남은 여유 자원으로 종료할 수 있는 프로세스 탐색 -> 해당 프로세스를 종료시키고 반환된 자원으로 다시 탐색.. 의 반복을 통해 모든 프로세스를 종료할 수 있는지.
  
- 자원 할당 그래프 알고리즘
  - 그래프를 그리고 향후 요청할 수 있는 자원을 점선을 예약 간선으로 표시.
  - 사이클이 발생한다면 자원 요청을 승인하지 않는다.

### ☝️ 교착상태의 탐지와 회복

#### ✏️ 탐지(Detection)
> 교착 상태가 발생했는지 탐지.
- 대기 그래프
  - 자원 할당 그래프에서 자원을 제거, 간선을 결합.
  - 다른 프로세스의 자원을 기다리는 것을 화살표로 표시.
  - 사이클이 생긴다면 교착상태를 의미.
- 은행원 알고리즘 : 불안정 상태라면 교착상태라고 판단.

#### ✏️ 회복(Recovery)
> 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제.

1. 프로세스 종료 방법
    1. 교착 상태의 프로세스를 모두 중지하는 방법.
    2. 교착 상태가 제거될 때 까지 하나씩 프로세스를 중지시켜 나감.

2. 자원 선점
    - 희생자 선택 : 최소의 피해를 가져오는 프로세스 선택후 자원을 해제, 다른 프로세스에게 할당.
      - 우선순위가 낮은 프로세스, 실행 빈도가 낮은 프로세스를 주로 선택한다.
      - 기아 상태가 발생할 수 있으므로 이를 해결하는 방법이 필요.(자원을 선점 당할때 마다 우선순위 증가 등.)
    - 롤백 : 선점된 프로세스를 이전 상태로 롤백(중단 후 재시작)
